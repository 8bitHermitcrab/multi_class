# -*- coding: utf-8 -*-
"""데이터_전처리_jiho_0502.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HI-4NYPUWx56MPzR7PFC-PnMliAYXRrZ

# 변수 설명
- **컬럼명 (컬럼 해석) : (데이터타입) 데이터 내용 (데이터 개수) "레이블"**

```
- index : (int64) 0 ~ 26456
- gender (성별) : (object) 
                 F(17697), M(8760)
- car (차량소유여부) : (object) 
                    Y(10047), N(16410)
- reality (부동산 소유 여부) : (object) 
                            Y(17830), N(8627)
- child_num (자녀수) : (int64) 
                      0(18340), 1(5386), 2(2362), 3(306), 
                      4(47), 5(10), 14(3), 7(2), 19(1)
- income_total (연간 소득): (float64)
- income_type (소득 분류) : (object) 
                          Working(13645) "4",
                          Commercial associate(6202) "0", 
                          Pensioner(4449) "1", 
                          State servant(2154) "2", 
                          Student(7) "3"
- edu_type (교육 수준) : (object) 
                        Secondary / secondary special(17995),
                        Higher education(7162), 
                        Incomplete higher(1020), 
                        Lower secondary(257), 
                        Academic degree(23)
- family_type (결혼 여부) : (object) 
                          Married 기혼(18196), 
                          Single / not married 미혼(3496), 
                          Civil marriage 동거혼?(2123), 
                          Separated 이혼(1539), Widow 미망인(1103)
- house_type (생활 방식) : (object)
                          House / apartment 자가(23653), 
                          With parents(1257), 
                          Municipal apartment 시립 아파트(818),
                          Rented apartment 임대 아파트(429),
                          Office apartment 사옥(190), 
                          Co-op apartment 주택조합 아파트(110)
- DAYS_BIRTH (출생일) : (int64)
                      0부터 역으로 셈. 
                      -1은 데이터 수집일 하루 전에 태어났음을 의미.
- DAYS_EMPLOYED (업무 시작일) : (int64)
                            0부터 역으로 셈. 
                            -1은 데이터 수집일 하루 전부터 일을 시작함을 의미. 
                            양수값은 고용되지 않은 상태를 의미.
- FLAG_MOBIL (핸드폰 소유 여부) : (int64) 
                              1(26457)
- work_phone (업무용 전화 소유 여부) : (int64) 
                                  0(20511), 1(5946)
- phone (가정용 전화 소유 여부) : (int64) 
                              0(18672), 1(7785)
- email (이메일 소유 여부) : (int64) 
                          0(24042), 1(2415)
- occyp_type (직업 유형) : (object) 
                        [nan, 'Laborers', 'Managers', 
                        'Sales staff', 'High skill tech staff',
                        'Core staff', 'Drivers', 
                        'Medicine staff', 'Accountants', 
                        'Realty agents', 'Security staff',
                        'Cleaning staff', 
                        'Private service staff', 
                        'Cooking staff', 'Secretaries', 
                        'HR staff', 'IT staff', 
                        'Low-skill Laborers', 
                        'Waiters/barmen staff']
- family_size (가족 규모) : (float64)
                          2.0(14106), 1.0(5109), 3.0(4632), 
                          4.0(2260), 5.0(291), 6.0(44), 7.0(9),
                          15.0(3), 9.0(2), 20.0(1)
- begin_month (신용카드 발급 월) : (float64)
                                0부터 역으로 셈. 
                                -1은 데이터 수집일 한달 전에 신용카드를 발급받음을 의미.
- credit (신용카드 대금 연체를 기준으로 한 신용도 ) : (float64)
                                              낮을수록 높은 신용의 신용카드 사용자 의미.)  
                                              0, 1, 2
```

# 데이터 불러오기
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import numpy as np
from sklearn.preprocessing import OneHotEncoder, LabelEncoder

path = '/content/drive/MyDrive/[멀캠 파이널 프로젝트] 신용카드 연체 예측/data/'

train = pd.read_csv(path + 'train.csv')
test = pd.read_csv(path + 'test.csv')

train_label = pd.read_csv(path + 'train.csv')

train

train.isnull().sum()

train.info()

"""## object 타입 레이블 인코딩
- gender (성별)
```
0 : F 
1 : M 
```
- car (차량 소유 여부)
```
0 : N 
1 : Y 
```
- reality (부동산 소유 여부)
```
0 : N 
1 : Y 
```
- income_type (소득 분류)
```
0 : Commercial associate
1 : Pensioner  
2 : State servant        
3 : Student              
4 : Working              
```
- edu_type (교육 수준)
```
0 : Academic degree               
1 : Higher education              
2 : Incomplete higher             
3 : Lower secondary               
4 : Secondary / secondary 
```
- family_type (결혼 여부)
```
0 : Civil marriage          
1 : Married               
2 : Separated                
3 : Single / not married     
4: Widow                    
```
- house_type (생활 방식)
```
0 : Co-op apartment          
1: House / apartment      
2: unicipal apartment      
3: Office apartment         
4: Rented apartment         
5: With parents            
```
- occyp_type (직업 유형)
```
0 : Accountants               
1 : Cleaning staff            
2 : Cooking staff             
3 : Core staff               
4 : Drivers                  
5 : High skill tech staff    
6 : HR staff                   
7 : IT staff                   
8 : Laborers                 
9 : Low-skill Laborers        
10 : Managers                 
11 : Medicine staff            
12 : Private service staff     
13 : Realty agents              
14 : Sales staff              
15 : Secretaries                
16 : Security staff            
17 : Waiters/barmen staff
18 : NaN      
```












"""

# gender 성별
print(train.gender.unique())
print(train['gender'].value_counts())

# car 차량 소유 여부
print(train.car.unique())
print(train['car'].value_counts())

# reality 부동산 소유 여부 
print(train.reality.unique())
print(train['reality'].value_counts())

# income_type 소득 분류 종류 (5가지)
print(train.income_type.unique())
print(train['income_type'].value_counts())

# edu_type 교육 수준 종류 (5가지)
print(train.edu_type.unique())
print(train['edu_type'].value_counts())

# family_type 결혼 여부 종류 (5가지)
print(train.family_type.unique())
print(train['family_type'].value_counts())

# house_type 생활 방식 종류 (6가지)
print(train.house_type.unique())
print(train['house_type'].value_counts())

# occyp_type 직업 유형 종류 (nan 제외 18가지)
print(train.occyp_type.unique())
print(train['occyp_type'].value_counts())

encoder = LabelEncoder()

# gender 라벨링
encoder.fit(train_label['gender'])
train_label['gender'] = encoder.transform(train_label['gender'])

# car 라벨링
encoder.fit(train_label['car'])
train_label['car'] = encoder.transform(train_label['car'])

# reality 라벨링
encoder.fit(train_label['reality'])
train_label['reality'] = encoder.transform(train_label['reality'])

# income_type 라벨링
encoder.fit(train_label['income_type'])
train_label['income_type'] = encoder.transform(train_label['income_type'])

# edu_type 라벨링
encoder.fit(train_label['edu_type'])
train_label['edu_type'] = encoder.transform(train_label['edu_type'])

# family_type 라벨링
encoder.fit(train_label['family_type'])
train_label['family_type'] = encoder.transform(train_label['family_type'])

# house_type 라벨링
encoder.fit(train_label['house_type'])
train_label['house_type'] = encoder.transform(train_label['house_type'])

# occyp_type 라벨링
encoder.fit(train_label['occyp_type'])
train_label['occyp_type'] = encoder.transform(train_label['occyp_type'])

train_label

"""## 중복행에 관하여
- credit은 사용자의 신용카드 대금 연체를 기준으로 한 신용도이다.
- 즉 동일인이어도 카드에 따라, 또 시점에 따라 연체 대금 연체 정도가 다를 수 있습니다.
"""



import seaborn as sns
import matplotlib.pyplot as plt

sns.heatmap(train_label, annot=True, linewidths=1)
plt.show()

corr_label = train_label.corr()
corr_label

import seaborn as sns
import matplotlib.pyplot as plt

corr_label = train_label.corr()

sns.heatmap(corr_label)

train_label2 = train_label.replace(365243, 0)
train_label2

(train_label2['DAYS_EMPLOYED'] == 365243).sum()

train_label2.corr()

corr_label2 = train_label2.corr()
sns.heatmap(corr_label2)

plt.figure(figsize=(15,15))
sns.heatmap(data = corr_label, annot=True, fmt = '.2f', linewidths=.5, cmap='Blues')

plt.figure(figsize=(15,15))
sns.heatmap(data = corr_label2, annot=True, fmt = '.2f', linewidths=.5, cmap='Blues')

# (train['DAYS_EMPLOYED'] <= 0 & train['occyp_type']= 18)
# jobless = train.replace(train['occyp_type']==None, jobless)


train2 = train.copy()

# train2[((train2[train2['income_type']== 'Pensioner') & (train2['DAYS_EMPLOYED'] < 0))] = 'jobless'

# train2((train2['income_type']== 'Pensioner') & (train2['DAYS_EMPLOYED'] < 0) ).replace('jobless')


# train2 = train2['DAYS_EMPLOYED'] < 0
# train2

# fillna('jobless')

# train2.replace[train2['income_type'] == ('Pensioner' and train2['DAYS_EMPLOYED'] < 0), 'jobless'] =
# train2.info()

# train2['income_type'] = train2['income_type'].apply('jobless' if train2['income_type'] == 'Pensioner' & train2['DAYS_EMPLOYED'] < 0)

# train2 = train2['income_type'] == 'Pensioner' & train2['DAYS_EMPLOYED'] < 0
# train2

train2 = train2[(train2['income_type'] == 'Pensioner') & (train2['DAYS_EMPLOYED'] < 0)]
(train2['DAYS_EMPLOYED'] >= 0).sum()

train3 = train2.replace('Pensioner', 'jobless')
train3

# 조건
train2 = train.copy()
train2 = train2[(train2['income_type'] == 'Pensioner') & (train2['DAYS_EMPLOYED'] < 0)]
print((train2['DAYS_EMPLOYED'] >= 0).sum())

# 연금수급자를 무직자로 바꾸기
train3 = train2.replace('Pensioner', 'jobless')
print(train3)

# 데이터 업데이트
train_combine = train.copy()
train_combine = train.append(train3, ignore_index=True)

# 확인
print(train_combine['income_type'].value_counts)

train_combine['income_type'].value_counts()

train_copy = train.copy()
con1 = train_copy['income_type'] == 'Pensioner'
train_copy['occyp_type'] = np.where(con1,'nojob','')
train_copy[con1]['occyp_type'] == 'nojob'

"""# 일수 컬럼을 나이로 변경"""

# 이상치 2개 값 제거
# train[(train['occyp_type'].isnull()) & (train['income_type'] == 'Pensioner') & (train['DAYS_EMPLOYED'] != 365243)]

train_del_2 = train.drop(train.index[6743])
train_del_2 = train_del_2.drop(train.index[15682])
train_del_2

# 나이로 변경
train_del_2['DAYS_BIRTH'] = round(train_del_2['DAYS_BIRTH']/-365)
train_del_2



"""# occyp_type 결측치 채우기"""

encoder = LabelEncoder()

# gender 라벨링
encoder.fit(train_del_2['gender'])
train_del_2['gender'] = encoder.transform(train_del_2['gender'])

# car 라벨링
encoder.fit(train_del_2['car'])
train_del_2['car'] = encoder.transform(train_del_2['car'])

# reality 라벨링
encoder.fit(train_del_2['reality'])
train_del_2['reality'] = encoder.transform(train_del_2['reality'])

# income_type 라벨링
encoder.fit(train_del_2['income_type'])
train_del_2['income_type'] = encoder.transform(train_del_2['income_type'])

# edu_type 라벨링
encoder.fit(train_del_2['edu_type'])
train_del_2['edu_type'] = encoder.transform(train_del_2['edu_type'])

# family_type 라벨링
encoder.fit(train_del_2['family_type'])
train_del_2['family_type'] = encoder.transform(train_del_2['family_type'])

# house_type 라벨링
encoder.fit(train_del_2['house_type'])
train_del_2['house_type'] = encoder.transform(train_del_2['house_type'])

# occyp_type 라벨링
encoder.fit(train_del_2['occyp_type'])
train_del_2['occyp_type'] = encoder.transform(train_del_2['occyp_type'])

"""# K-평균 군집화(k-means clustering)

Working(13645) "4",
                          Commercial associate(6202) "0", 
                          Pensioner(4449) "1", 
                          State servant(2154) "2", 
                          Student
"""

train_del_2 = train_del_2.dropna()

# 최소값을 0, 최대값을 1에 매핑하는 MinMaxScaler
from sklearn.preprocessing import MinMaxScaler

data = train_del_2[['income_total']] # , 'DAYS_BIRTH', 'work_phone', 'occyp_type'

# 정규화
scaler = MinMaxScaler()
data_scale = scaler.fit_transform(data)

# k-mean
from sklearn.cluster import KMeans

k = 18

# 그룹 수, random_state 설정
model = KMeans(n_clusters = k, random_state = 10)

# data = train_del_2['occyp_type', 'income_total', 'DAYS_BIRTH', 'work_phone']

# 정규화된 데이터에 학습
model.fit(data)

# 클러스터링 결과 각 데이터가 몇 번째 그룹에 속하는지 저장
train_del_2['cluster'] = model.fit_predict(data_scale)

train_del_2['income_total']

# 시각화
# import matplotlib.pyplot as plt

plt.figure(figsize = (10, 10))

for i in range(k):
    plt.scatter(train_del_2.loc[train_del_2['cluster'] == i, 'income_total'], 
                train_del_2.loc[train_del_2['cluster'] == i, 'occyp_type'], 
                label = 'cluster ' + str(i))

plt.legend()
plt.title('K = %d results'%k , size = 15)
plt.xlabel('income_total', size = 12)
plt.ylabel('occyp_type', size = 19)
plt.show()

from sklearn.preprocessing import StandardScaler
scaler2 = StandardScaler()
# 메소드체이닝(chaining)을 사용하여 fit과 transform을 연달아 호출합니다
X_scaled = scaler2.fit(train_del_2).transform(train_del_2)

# 위와 동일하지만 더 효율적입니다(fit_transform)
X_scaled_d = scaler2.fit_transform(train_del_2)

#해당 fit으로 test데이터도 transform 해줍니다
X_train_scaled = scaler2.transform(train_del_2)

plt.scatter(X_scaled[:,0],X_scaled[:,1])

train_del_2

processed_data = train_del_2.dropna()

processed_data_del = processed_data[['income_total', 'income_type', 'DAYS_BIRTH', 'occyp_type', 'cluster']]
processed_data_del

pro_occyp_type = processed_data_del[processed_data_del['occyp_type'] == 8] # Laborers
pro_occyp_type

sns.pairplot(processed_data_del, hue="occyp_type", markers=["o", "v", "^", '<','>', '8', 's', 'p', '*', 'h', 'H', 'D', 'd', 'P', 'X', 'o', 'X' ,'^'])
plt.title("0")
plt.show()

from sklearn.decomposition import PCA

pca = PCA(n_components=18) # 주성분 18개
pca_transformed = pca.fit_transform(processed_data)

processed_data_del['pca_x'] = pca_transformed[:,0]
processed_data_del['pca_y'] = pca_transformed[:,1]
processed_data_del.head(3)

# cluster 값이 0, 1, 2 인 경우마다 별도의 Index로 추출
marker0_ind = processed_data_del[processed_data_del['cluster']==0].index
marker1_ind = processed_data_del[processed_data_del['cluster']==1].index
marker2_ind = processed_data_del[processed_data_del['cluster']==2].index

# cluster값 0, 1, 2에 해당하는 Index로 각 cluster 레벨의 pca_x, pca_y 값 추출. o, s, ^ 로 marker 표시
plt.scatter(x=processed_data_del.loc[marker0_ind,'pca_x'], y=processed_data_del.loc[marker0_ind,'pca_y'], marker='o') 
plt.scatter(x=processed_data_del.loc[marker1_ind,'pca_x'], y=processed_data_del.loc[marker1_ind,'pca_y'], marker='s')
plt.scatter(x=processed_data_del.loc[marker2_ind,'pca_x'], y=processed_data_del.loc[marker2_ind,'pca_y'], marker='^')

plt.xlabel('PCA 1')
plt.ylabel('PCA 2')
plt.title('3 Clusters Visualization by 2 PCA Components')
plt.show()

